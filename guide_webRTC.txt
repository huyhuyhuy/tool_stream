# üöÄ H∆Ø·ªöNG D·∫™N WEBRTC STREAMING - CH·∫§T L∆Ø·ª¢NG CAO

## üìã T·ªîNG QUAN
WebRTC (Web Real-Time Communication) cho ph√©p streaming video/audio real-time v·ªõi:
- ‚úÖ 30-60 FPS m∆∞·ª£t m√†
- ‚úÖ Video compression H.264/VP8 hi·ªáu qu·∫£
- ‚úÖ Audio streaming
- ‚úÖ Latency th·∫•p (50-100ms)
- ‚úÖ T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh quality theo bandwidth

## üèóÔ∏è KI·∫æN TR√öC H·ªÜ TH·ªêNG

```
[Windows PC] --WebRTC--> [Signaling Server VPS] --WebRTC--> [Web Viewers]
     ‚Üì                           ‚Üì                              ‚Üì
Screen Capture              Socket.IO Server              HTML5 Player
Media Stream               Relay Messages                 Auto Quality
```

## üñ•Ô∏è PH·∫¶N 1: C√ÄI ƒê·∫∂T VPS (SIGNALING SERVER)

### B∆∞·ªõc 1: C√†i ƒë·∫∑t Node.js tr√™n VPS
```bash
# C·∫≠p nh·∫≠t h·ªá th·ªëng
sudo apt update && sudo apt upgrade -y

# C√†i ƒë·∫∑t Node.js v√† npm
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs

# Ki·ªÉm tra version
node --version
npm --version
```

### B∆∞·ªõc 2: T·∫°o Signaling Server
```bash
# T·∫°o th∆∞ m·ª•c project
mkdir ~/webrtc_server
cd ~/webrtc_server

# Kh·ªüi t·∫°o npm project
npm init -y

# C√†i ƒë·∫∑t dependencies
npm install express socket.io cors
```

### B∆∞·ªõc 3: T·∫°o file server.js (Signaling Server)

**3.1. T·∫°o file server.js:**
```bash
# ƒê·∫£m b·∫£o b·∫°n ƒëang ·ªü th∆∞ m·ª•c ~/webrtc_server
cd ~/webrtc_server

# T·∫°o file server.js b·∫±ng nano editor
nano server.js
```

**3.2. Copy v√† paste n·ªôi dung sau v√†o file server.js:**
(Trong nano, nh·∫•n Ctrl+Shift+V ƒë·ªÉ paste)

```javascript
// server.js - WebRTC Signaling Server
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const path = require('path');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});

// Serve static files t·ª´ th∆∞ m·ª•c public
app.use(express.static(path.join(__dirname, 'public')));

// L∆∞u tr·ªØ c√°c client ƒë√£ k·∫øt n·ªëi
let broadcaster = null;  // Windows PC broadcaster
const viewers = new Set();  // Web viewers

// X·ª≠ l√Ω k·∫øt n·ªëi WebSocket
io.on('connection', (socket) => {
    console.log('Client connected:', socket.id);
    
    // Windows PC ƒëƒÉng k√Ω l√†m broadcaster (ng∆∞·ªùi ph√°t)
    socket.on('broadcaster', () => {
        broadcaster = socket.id;
        console.log('Broadcaster connected:', socket.id);
        socket.broadcast.emit('broadcaster-connected');
    });
    
    // Web viewers ƒëƒÉng k√Ω (ng∆∞·ªùi xem)
    socket.on('viewer', () => {
        viewers.add(socket.id);
        console.log('Viewer connected:', socket.id);
        
        if (broadcaster) {
            socket.to(broadcaster).emit('viewer-connected', socket.id);
        }
    });
    
    // Relay WebRTC signaling messages
    socket.on('offer', (data) => {
        socket.to(data.target).emit('offer', {
            offer: data.offer,
            broadcaster: socket.id
        });
    });
    
    socket.on('answer', (data) => {
        socket.to(data.target).emit('answer', data.answer);
    });
    
    socket.on('ice-candidate', (data) => {
        socket.to(data.target).emit('ice-candidate', data.candidate);
    });
    
    // X·ª≠ l√Ω ng·∫Øt k·∫øt n·ªëi
    socket.on('disconnect', () => {
        console.log('Client disconnected:', socket.id);
        
        if (socket.id === broadcaster) {
            broadcaster = null;
            socket.broadcast.emit('broadcaster-disconnected');
        }
        
        viewers.delete(socket.id);
    });
});

// Kh·ªüi ƒë·ªông server
const PORT = process.env.PORT || 3000;
server.listen(PORT, '0.0.0.0', () => {
    console.log(`üöÄ WebRTC Signaling Server running on port ${PORT}`);
    console.log(`üåê Public URL: http://45.76.190.6:${PORT}`);
    console.log(`üìÅ Serving files from: ${path.join(__dirname, 'public')}`);
});
```

**3.3. L∆∞u file trong nano:**
```bash
# Nh·∫•n Ctrl+X ƒë·ªÉ tho√°t
# Nh·∫•n Y ƒë·ªÉ confirm save
# Nh·∫•n Enter ƒë·ªÉ confirm filename
```

**3.4. Ki·ªÉm tra file ƒë√£ t·∫°o:**
```bash
# Ki·ªÉm tra file c√≥ t·ªìn t·∫°i kh√¥ng
ls -la server.js

# Xem n·ªôi dung file (optional)
cat server.js
```

**3.5. Test ch·∫°y server (optional):**
```bash
# Test ch·∫°y server ƒë·ªÉ ki·ªÉm tra syntax
node server.js

# N·∫øu th√†nh c√¥ng, b·∫°n s·∫Ω th·∫•y:
# üöÄ WebRTC Signaling Server running on port 3000
# üåê Public URL: http://45.76.190.6:3000
# üìÅ Serving files from: /root/webrtc_server/public

# Nh·∫•n Ctrl+C ƒë·ªÉ d·ª´ng (ch√∫ng ta s·∫Ω ch·∫°y l·∫°i sau)
```

### B∆∞·ªõc 4: T·∫°o th∆∞ m·ª•c public v√† file web viewer

**4.1. T·∫°o th∆∞ m·ª•c public:**
```bash
# ƒê·∫£m b·∫£o b·∫°n ƒëang ·ªü th∆∞ m·ª•c ~/webrtc_server
cd ~/webrtc_server

# T·∫°o th∆∞ m·ª•c public ƒë·ªÉ ch·ª©a file HTML
mkdir public

# Ki·ªÉm tra th∆∞ m·ª•c ƒë√£ t·∫°o
ls -la
```

**4.2. T·∫°o file index.html:**
```bash
# V√†o th∆∞ m·ª•c public
cd public

# T·∫°o file index.html b·∫±ng nano
nano index.html
```

**4.3. Copy v√† paste n·ªôi dung HTML sau v√†o file index.html:**
(Trong nano, nh·∫•n Ctrl+Shift+V ƒë·ªÉ paste)

```html
<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Live Stream</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background: #f0f0f0; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            text-align: center; 
        }
        video { 
            width: 100%; 
            max-width: 1000px; 
            height: auto; 
            border: 3px solid #333; 
            border-radius: 10px; 
            background: #000; 
        }
        .status { 
            padding: 15px; 
            margin: 20px 0; 
            border-radius: 8px; 
            font-weight: bold; 
            font-size: 16px;
        }
        .online { background: #d4edda; color: #155724; }
        .offline { background: #f8d7da; color: #721c24; }
        .connecting { background: #d1ecf1; color: #0c5460; }
        h1 { color: #333; margin-bottom: 10px; }
        .info { color: #666; margin-bottom: 30px; font-size: 14px; }
        .server-info { 
            background: #fff; 
            padding: 15px; 
            border-radius: 8px; 
            margin: 20px 0; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé• Live Stream from Windows PC</h1>
        <div class="info">Real-time WebRTC streaming with high quality video</div>
        
        <div class="server-info">
            <strong>Server:</strong> VPS WebRTC Signaling Server<br>
            <strong>Quality:</strong> HD 720p-1080p | <strong>FPS:</strong> 30 FPS
        </div>
        
        <div id="status" class="status offline">
            üîÑ Connecting to server...
        </div>
        
        <video id="remoteVideo" autoplay playsinline muted controls>
            Your browser doesn't support video playback.
        </video>
        
        <div class="info" style="margin-top: 20px;">
            <strong>Tips:</strong> N·∫øu kh√¥ng th·∫•y video, h√£y ki·ªÉm tra Windows PC ƒë√£ b·∫≠t broadcaster ch∆∞a
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        console.log('üöÄ WebRTC Viewer started');
        
        const socket = io();
        const remoteVideo = document.getElementById('remoteVideo');
        const statusDiv = document.getElementById('status');
        
        let peerConnection;
        let isConnected = false;
        
        // WebRTC configuration v·ªõi STUN servers
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };
        
        function updateStatus(message, className) {
            statusDiv.innerHTML = message;
            statusDiv.className = `status ${className}`;
            console.log('Status:', message);
        }
        
        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(configuration);
            console.log('üîó Created peer connection');
            
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('üì° Sending ICE candidate to broadcaster');
                    socket.emit('ice-candidate', {
                        target: broadcasterSocketId,
                        candidate: event.candidate
                    });
                }
            };
            
            peerConnection.ontrack = (event) => {
                console.log('üé• Received remote stream!');
                remoteVideo.srcObject = event.streams[0];
                isConnected = true;
                updateStatus('üü¢ <strong>LIVE</strong> - Streaming from Windows PC', 'online');
            };
            
            peerConnection.onconnectionstatechange = () => {
                const state = peerConnection.connectionState;
                console.log('Connection state:', state);
                
                if (state === 'connected') {
                    updateStatus('üü¢ <strong>LIVE</strong> - Connected to Windows PC', 'online');
                } else if (state === 'disconnected' || state === 'failed') {
                    isConnected = false;
                    updateStatus('üî¥ <strong>OFFLINE</strong> - Windows PC disconnected', 'offline');
                } else if (state === 'connecting') {
                    updateStatus('üü° <strong>CONNECTING</strong> - Establishing connection...', 'connecting');
                }
            };
            
            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', peerConnection.iceConnectionState);
            };
        }
        
        let broadcasterSocketId;
        
        // Socket.IO event handlers
        socket.on('connect', () => {
            console.log('‚úÖ Connected to signaling server');
            updateStatus('üü° <strong>CONNECTED</strong> - Waiting for Windows PC...', 'connecting');
            socket.emit('viewer');
        });
        
        socket.on('broadcaster-connected', () => {
            console.log('üì¢ Broadcaster (Windows PC) connected');
            updateStatus('üü° <strong>FOUND</strong> - Windows PC found, establishing connection...', 'connecting');
        });
        
        socket.on('broadcaster-disconnected', () => {
            console.log('üì¢ Broadcaster disconnected');
            isConnected = false;
            updateStatus('üî¥ <strong>OFFLINE</strong> - Windows PC disconnected', 'offline');
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
        });
        
        socket.on('offer', async (data) => {
            console.log('üì® Received offer from broadcaster');
            broadcasterSocketId = data.broadcaster;
            
            createPeerConnection();
            
            try {
                await peerConnection.setRemoteDescription(data.offer);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                socket.emit('answer', {
                    target: broadcasterSocketId,
                    answer: answer
                });
                console.log('üì§ Sent answer to broadcaster');
            } catch (error) {
                console.error('‚ùå Error handling offer:', error);
                updateStatus('üî¥ <strong>ERROR</strong> - Connection failed', 'offline');
            }
        });
        
        socket.on('ice-candidate', async (candidate) => {
            if (peerConnection) {
                try {
                    await peerConnection.addIceCandidate(candidate);
                    console.log('üì° Added ICE candidate');
                } catch (error) {
                    console.error('‚ùå Error adding ICE candidate:', error);
                }
            }
        });
        
        socket.on('disconnect', () => {
            console.log('‚ùå Disconnected from server');
            updateStatus('üî¥ <strong>OFFLINE</strong> - Server connection lost', 'offline');
        });
        
        // Error handling
        window.addEventListener('error', (event) => {
            console.error('üö® Global error:', event.error);
        });
        
        // Page visibility handling
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && !isConnected) {
                console.log('üîÑ Page visible, attempting reconnection...');
                socket.connect();
            }
        });
    </script>
</body>
</html>
```

**4.4. L∆∞u file index.html:**
```bash
# Trong nano:
Ctrl+X   # Tho√°t
Y        # Confirm save
Enter    # Confirm filename
```

**4.5. Ki·ªÉm tra c·∫•u tr√∫c th∆∞ m·ª•c:**
```bash
# Quay v·ªÅ th∆∞ m·ª•c ch√≠nh
cd ~/webrtc_server

# Ki·ªÉm tra c·∫•u tr√∫c
ls -la
ls -la public/

# B·∫°n s·∫Ω th·∫•y:
# ~/webrtc_server/
# ‚îú‚îÄ‚îÄ server.js
# ‚îú‚îÄ‚îÄ public/
# ‚îÇ   ‚îî‚îÄ‚îÄ index.html
# ‚îú‚îÄ‚îÄ package.json
# ‚îî‚îÄ‚îÄ node_modules/
```

**4.6. Test c·∫•u tr√∫c file:**
```bash
# Ki·ªÉm tra n·ªôi dung file HTML (optional)
head -20 public/index.html

# Ki·ªÉm tra k√≠ch th∆∞·ªõc file
du -h public/index.html
```

### B∆∞·ªõc 5: C·∫•u h√¨nh v√† ch·∫°y server tr√™n VPS

**5.1. M·ªü port cho VPS:**
```bash
# Ki·ªÉm tra firewall status
sudo ufw status

# M·ªü port 3000 cho WebRTC server
sudo ufw allow 3000

# M·ªü port 80 (HTTP) n·∫øu ch∆∞a c√≥
sudo ufw allow 80

# M·ªü port 443 (HTTPS) n·∫øu ch∆∞a c√≥  
sudo ufw allow 443

# Ki·ªÉm tra l·∫°i
sudo ufw status
```

**5.2. Test ch·∫°y server:**
```bash
# ƒê·∫£m b·∫£o b·∫°n ƒëang ·ªü th∆∞ m·ª•c ~/webrtc_server
cd ~/webrtc_server

# Ch·∫°y server
node server.js

# B·∫°n s·∫Ω th·∫•y output:
# üöÄ WebRTC Signaling Server running on port 3000
# üåê Public URL: http://45.76.190.6:3000
# üìÅ Serving files from: /root/webrtc_server/public
```

**5.3. Test truy c·∫≠p web:**
```bash
# M·ªü browser tr√™n m√°y t√≠nh v√† truy c·∫≠p:
# http://45.76.190.6:3000

# B·∫°n s·∫Ω th·∫•y trang web v·ªõi:
# - Title: "Live Stream from Windows PC"
# - Status: "CONNECTED - Waiting for Windows PC..."
# - Video player (m√†u ƒëen)
```

**5.4. Ch·∫°y server background (optional):**
```bash
# N·∫øu mu·ªën ch·∫°y server background, s·ª≠ d·ª•ng screen ho·∫∑c nohup

# C√°ch 1: S·ª≠ d·ª•ng screen
sudo apt install screen
screen -S webrtc_server
node server.js
# Nh·∫•n Ctrl+A r·ªìi D ƒë·ªÉ detach

# C√°ch 2: S·ª≠ d·ª•ng nohup
nohup node server.js > server.log 2>&1 &

# Ki·ªÉm tra process
ps aux | grep node
```

**5.5. Ki·ªÉm tra log (n·∫øu d√πng nohup):**
```bash
# Xem log real-time
tail -f server.log

# Xem log cu·ªëi c√πng
tail -20 server.log
```

## üíª PH·∫¶N 2: C√ÄI ƒê·∫∂T WINDOWS CLIENT

### B∆∞·ªõc 1: Chu·∫©n b·ªã m√¥i tr∆∞·ªùng Windows

**1.1. Ki·ªÉm tra Python:**
```bash
# M·ªü Command Prompt ho·∫∑c PowerShell
# Ki·ªÉm tra Python version
python --version

# N·∫øu ch∆∞a c√≥ Python, t·∫£i t·ª´: https://www.python.org/downloads/
# Ch·ªçn "Add Python to PATH" khi c√†i ƒë·∫∑t
```

**1.2. C√†i ƒë·∫∑t Python packages:**
```bash
# C√†i ƒë·∫∑t c√°c package c·∫ßn thi·∫øt
pip install opencv-python
pip install numpy
pip install pyautogui  
pip install pygetwindow
pip install pywin32
pip install websockets
pip install asyncio
pip install tkinter

# Ho·∫∑c c√†i ƒë·∫∑t t·∫•t c·∫£ c√πng l√∫c:
pip install opencv-python numpy pyautogui pygetwindow pywin32 websockets asyncio tkinter
```

**1.3. Ki·ªÉm tra c√†i ƒë·∫∑t:**
```bash
# Test import c√°c package
python -c "import cv2; print('OpenCV:', cv2.__version__)"
python -c "import numpy; print('NumPy:', numpy.__version__)"
python -c "import pygetwindow; print('PyGetWindow: OK')"
python -c "import win32gui; print('PyWin32: OK')"
python -c "import websockets; print('WebSockets: OK')"
```

**1.4. C√†i ƒë·∫∑t th√™m (n·∫øu c·∫ßn):**
```bash
# N·∫øu g·∫∑p l·ªói import cv2
pip uninstall opencv-python
pip install opencv-python-headless

# N·∫øu g·∫∑p l·ªói pywin32
pip install --upgrade pywin32
# Sau ƒë√≥ ch·∫°y:
python Scripts/pywin32_postinstall.py -install
```

### B∆∞·ªõc 2: T·∫°o file Windows Broadcaster

**2.1. T·∫°o th∆∞ m·ª•c l√†m vi·ªác:**
```bash
# T·∫°o th∆∞ m·ª•c cho project
mkdir C:\webrtc_windows
cd C:\webrtc_windows

# Ho·∫∑c t·∫°o ·ªü v·ªã tr√≠ b·∫°n mu·ªën:
# mkdir D:\DEV_TOOL\webrtc_client
# cd D:\DEV_TOOL\webrtc_client
```

**2.2. T·∫°o file webrtc_broadcaster.py:**
```bash
# T·∫°o file b·∫±ng notepad ho·∫∑c editor y√™u th√≠ch
notepad webrtc_broadcaster.py

# Ho·∫∑c d√πng command line:
echo. > webrtc_broadcaster.py
```

**2.3. Copy v√† paste code sau v√†o file webrtc_broadcaster.py:**

**L∆ØU √ù**: Code n√†y r·∫•t d√†i (500+ d√≤ng). H√£y copy t·ª´ng ph·∫ßn m·ªôt c√°ch c·∫©n th·∫≠n.

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
WebRTC Broadcaster for Windows
Captures Chrome window and streams to VPS via WebRTC
"""

import asyncio
import websockets
import json
import cv2
import numpy as np
import base64
import threading
import time
import win32gui
import win32ui
import pygetwindow as gw
import ctypes
from tkinter import *
from tkinter import ttk, messagebox

class WebRTCBroadcaster:
    def __init__(self):
        # C·∫•u h√¨nh VPS - THAY ƒê·ªîI IP VPS C·ª¶A B·∫†N
        self.vps_ip = "45.76.190.6"  # Thay ƒë·ªïi IP n√†y
        self.vps_port = 3000
        
        self.websocket = None
        self.broadcasting = False
        self.selected_window = None
        
        # Create GUI
        self.setup_gui()
        
    def setup_gui(self):
        """T·∫°o giao di·ªán ng∆∞·ªùi d√πng"""
        self.root = Tk()
        self.root.title("üé• WebRTC Broadcaster")
        self.root.geometry("600x400")
        self.root.resizable(True, True)
        
        # Main frame
        main_frame = Frame(self.root, padx=20, pady=20)
        main_frame.pack(fill='both', expand=True)
        
        # Title
        title_label = Label(main_frame, text="üé• WebRTC Screen Broadcaster", 
                          font=("Arial", 18, "bold"), fg="#333")
        title_label.pack(pady=10)
        
        # VPS Info frame
        vps_frame = LabelFrame(main_frame, text="üåê VPS Configuration", 
                              font=("Arial", 10, "bold"), padx=10, pady=10)
        vps_frame.pack(fill='x', pady=10)
        
        Label(vps_frame, text=f"VPS Server: {self.vps_ip}:{self.vps_port}", 
              font=("Arial", 10)).pack(anchor='w')
        Label(vps_frame, text=f"Public Stream: http://{self.vps_ip}:{self.vps_port}", 
              font=("Arial", 10), fg="blue").pack(anchor='w')
        
        # Chrome window selection frame
        window_frame = LabelFrame(main_frame, text="üñºÔ∏è Window Selection", 
                                 font=("Arial", 10, "bold"), padx=10, pady=10)
        window_frame.pack(fill='x', pady=10)
        
        Label(window_frame, text="Select Chrome Window:", 
              font=("Arial", 10)).pack(anchor='w', pady=(5,5))
        
        self.window_var = StringVar()
        self.window_combo = ttk.Combobox(window_frame, textvariable=self.window_var, 
                                        state='readonly', width=70, font=("Arial", 9))
        self.window_combo.pack(fill='x', pady=5)
        self.window_combo.bind('<<ComboboxSelected>>', self.select_window)
        
        # Buttons frame
        btn_frame = Frame(window_frame)
        btn_frame.pack(pady=10)
        
        self.refresh_btn = Button(btn_frame, text="üîÑ Refresh Windows", 
                                 command=self.refresh_windows,
                                 font=("Arial", 10), bg="#f0f0f0")
        self.refresh_btn.pack(side='left', padx=5)
        
        self.broadcast_btn = Button(btn_frame, text="üöÄ Start Broadcasting", 
                                   command=self.toggle_broadcast,
                                   font=("Arial", 10, "bold"),
                                   state='disabled', bg="#4CAF50", fg="white")
        self.broadcast_btn.pack(side='left', padx=5)
        
        # Status frame
        status_frame = LabelFrame(main_frame, text="üìä Status", 
                                 font=("Arial", 10, "bold"), padx=10, pady=10)
        status_frame.pack(fill='x', pady=10)
        
        self.status_label = Label(status_frame, text="üîµ Ready - Select a Chrome window to start", 
                                 font=("Arial", 11), fg="blue", wraplength=500)
        self.status_label.pack(pady=5)
        
        # Instructions
        instructions = """
üîß H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG:
1. M·ªü Chrome browser v·ªõi tab/trang b·∫°n mu·ªën stream
2. Click "Refresh Windows" ƒë·ªÉ t·∫£i danh s√°ch c·ª≠a s·ªï Chrome
3. Ch·ªçn c·ª≠a s·ªï Chrome t·ª´ dropdown
4. Click "Start Broadcasting" ƒë·ªÉ b·∫Øt ƒë·∫ßu stream
5. Truy c·∫≠p http://45.76.190.6:3000 ƒë·ªÉ xem stream
        """
        
        instructions_label = Label(main_frame, text=instructions, 
                                  font=("Arial", 9), fg="#666", 
                                  justify='left', wraplength=550)
        instructions_label.pack(pady=10)
        
        # Load windows on start
        self.root.after(1000, self.refresh_windows)
        
    def refresh_windows(self):
        """Refresh Chrome windows list"""
        try:
            chrome_windows = []
            windows = gw.getWindowsWithTitle('')
            
            for window in windows:
                if ('chrome' in window.title.lower() and 
                    window.visible and 
                    len(window.title.strip()) > 0 and
                    window.title.strip() != 'Chrome'):
                    
                    # Truncate long titles
                    title = window.title[:60] + "..." if len(window.title) > 60 else window.title
                    chrome_windows.append(f"{title} (HWND: {window._hWnd})")
            
            self.window_combo['values'] = chrome_windows
            
            if chrome_windows:
                self.status_label.config(text=f"‚úÖ Found {len(chrome_windows)} Chrome windows", fg="green")
            else:
                self.status_label.config(text="‚ö†Ô∏è No Chrome windows found - Please open Chrome browser", fg="orange")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error refreshing windows: {str(e)}")
            self.status_label.config(text="‚ùå Error refreshing windows", fg="red")
    
    def select_window(self, event=None):
        """Select Chrome window"""
        try:
            selected_text = self.window_var.get()
            if not selected_text:
                return
                
            # Extract HWND
            hwnd_str = selected_text.split('(HWND: ')[1].rstrip(')')
            hwnd = int(hwnd_str)
            
            # Get window object
            for w in gw.getWindowsWithTitle(''):
                if w._hWnd == hwnd:
                    self.selected_window = w
                    self.broadcast_btn.config(state='normal')
                    window_title = w.title[:50] + "..." if len(w.title) > 50 else w.title
                    self.status_label.config(text=f"üéØ Selected: {window_title}", fg="blue")
                    break
                    
        except Exception as e:
            messagebox.showerror("Error", f"Error selecting window: {str(e)}")
            self.status_label.config(text="‚ùå Error selecting window", fg="red")
    
    def capture_window(self):
        """Capture selected Chrome window using PrintWindow API"""
        if not self.selected_window:
            return None
            
        try:
            hwnd = self.selected_window._hWnd
            
            # Check if window still exists
            if not win32gui.IsWindow(hwnd):
                return None
                
            left, top, right, bottom = win32gui.GetWindowRect(hwnd)
            width = right - left
            height = bottom - top
            
            if width <= 0 or height <= 0:
                return None
            
            # Use PrintWindow API for reliable capture
            user32 = ctypes.windll.user32
            hwndDC = win32gui.GetWindowDC(hwnd)
            mfcDC = win32ui.CreateDCFromHandle(hwndDC)
            saveDC = mfcDC.CreateCompatibleDC()
            
            saveBitMap = win32ui.CreateBitmap()
            saveBitMap.CreateCompatibleBitmap(mfcDC, width, height)
            saveDC.SelectObject(saveBitMap)
            
            # PW_RENDERFULLCONTENT = 3
            result = user32.PrintWindow(hwnd, saveDC.GetSafeHdc(), 3)
            
            if result:
                bmpstr = saveBitMap.GetBitmapBits(True)
                img = np.frombuffer(bmpstr, dtype='uint8')
                img.shape = (height, width, 4)  # BGRA format
                img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
                
                # Cleanup resources
                win32gui.DeleteObject(saveBitMap.GetHandle())
                saveDC.DeleteDC()
                mfcDC.DeleteDC()
                win32gui.ReleaseDC(hwnd, hwndDC)
                
                return img
            else:
                # Cleanup on failure
                win32gui.DeleteObject(saveBitMap.GetHandle())
                saveDC.DeleteDC()
                mfcDC.DeleteDC()
                win32gui.ReleaseDC(hwnd, hwndDC)
                return None
                
        except Exception as e:
            print(f"‚ùå Capture error: {e}")
            return None
    
    async def connect_websocket(self):
        """Connect to WebRTC signaling server"""
        try:
            uri = f"ws://{self.vps_ip}:{self.vps_port}/socket.io/?EIO=4&transport=websocket"
            self.websocket = await websockets.connect(uri, ping_interval=20, ping_timeout=10)
            
            # Register as broadcaster
            await self.websocket.send('40')  # Connect message
            await self.websocket.send('42["broadcaster"]')  # Register as broadcaster
            
            self.status_label.config(text="üü¢ Connected to VPS - Broadcasting...", fg="green")
            
            # Start capture and receive loops
            await asyncio.gather(
                self.broadcast_loop(),
                self.receive_messages()
            )
            
        except Exception as e:
            self.status_label.config(text=f"‚ùå Connection failed: {str(e)}", fg="red")
            print(f"WebSocket error: {e}")
    
    async def receive_messages(self):
        """Receive messages from signaling server"""
        try:
            async for message in self.websocket:
                if message.startswith('42'):
                    # Parse Socket.IO message
                    try:
                        data = json.loads(message[2:])
                        if isinstance(data, list) and len(data) > 0:
                            event = data[0]
                            if event == "viewer-connected":
                                print(f"üëÄ Viewer connected: {data[1] if len(data) > 1 else 'Unknown'}")
                            elif event == "offer":
                                print("üì® Received WebRTC offer")
                            elif event == "answer":
                                print("üì® Received WebRTC answer")
                    except:
                        pass
        except Exception as e:
            print(f"‚ùå Error receiving messages: {e}")
    
    async def broadcast_loop(self):
        """Main broadcasting loop"""
        frame_count = 0
        while self.broadcasting:
            try:
                # Capture frame
                frame = self.capture_window()
                if frame is not None:
                    # Optimize frame size for streaming
                    h, w = frame.shape[:2]
                    max_width = 1280
                    if w > max_width:
                        scale = max_width / w
                        new_w = int(w * scale)
                        new_h = int(h * scale)
                        frame = cv2.resize(frame, (new_w, new_h), interpolation=cv2.INTER_LANCZOS4)
                    
                    # Encode to JPEG with good quality
                    encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), 85]
                    _, buffer = cv2.imencode('.jpg', frame, encode_param)
                    frame_b64 = base64.b64encode(buffer).decode('utf-8')
                    
                    # Send frame via WebSocket
                    message = json.dumps({
                        "type": "video_frame",
                        "data": frame_b64,
                        "frame": frame_count,
                        "timestamp": time.time()
                    })
                    
                    if self.websocket and not self.websocket.closed:
                        await self.websocket.send(f'42["video_frame",{message}]')
                        frame_count += 1
                        
                        # Update status every 30 frames
                        if frame_count % 30 == 0:
                            self.status_label.config(
                                text=f"üî¥ LIVE - Broadcasting frame #{frame_count}", 
                                fg="red"
                            )
                else:
                    # No frame captured, window might be minimized/closed
                    if frame_count % 30 == 0:  # Check every 30 attempts
                        self.status_label.config(
                            text="‚ö†Ô∏è Cannot capture window - Is Chrome still open?", 
                            fg="orange"
                        )
                
                await asyncio.sleep(1/30)  # 30 FPS
                
            except Exception as e:
                print(f"‚ùå Broadcast error: {e}")
                await asyncio.sleep(1)
    
    def toggle_broadcast(self):
        """Start/stop broadcasting"""
        if not self.broadcasting:
            if not self.selected_window:
                messagebox.showerror("Error", "Please select a Chrome window first!")
                return
                
            self.broadcasting = True
            self.broadcast_btn.config(text="üõë Stop Broadcasting", bg="#f44336")
            self.status_label.config(text="üü° Connecting to VPS...", fg="orange")
            
            # Disable window selection while broadcasting
            self.window_combo.config(state='disabled')
            self.refresh_btn.config(state='disabled')
            
            # Start WebSocket in separate thread
            def run_websocket():
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                try:
                    loop.run_until_complete(self.connect_websocket())
                except Exception as e:
                    print(f"‚ùå WebSocket thread error: {e}")
                finally:
                    loop.close()
            
            self.websocket_thread = threading.Thread(target=run_websocket, daemon=True)
            self.websocket_thread.start()
            
        else:
            self.stop_broadcasting()
    
    def stop_broadcasting(self):
        """Stop broadcasting"""
        self.broadcasting = False
        self.broadcast_btn.config(text="üöÄ Start Broadcasting", bg="#4CAF50")
        self.status_label.config(text="üîµ Broadcasting stopped", fg="blue")
        
        # Re-enable controls
        self.window_combo.config(state='readonly')
        self.refresh_btn.config(state='normal')
        
        # Close WebSocket
        if self.websocket and not self.websocket.closed:
            asyncio.create_task(self.websocket.close())
    
    def on_closing(self):
        """Handle window closing"""
        if self.broadcasting:
            self.stop_broadcasting()
        self.root.destroy()
    
    def run(self):
        """Run the application"""
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        print("üöÄ WebRTC Broadcaster started")
        print(f"üåê VPS Server: {self.vps_ip}:{self.vps_port}")
        print(f"üì∫ Public Stream: http://{self.vps_ip}:{self.vps_port}")
        self.root.mainloop()

if __name__ == "__main__":
    try:
        # Check if running as administrator (recommended)
        import ctypes
        if ctypes.windll.shell32.IsUserAnAdmin():
            print("‚úÖ Running as Administrator")
        else:
            print("‚ö†Ô∏è Not running as Administrator - Some captures might fail")
        
        broadcaster = WebRTCBroadcaster()
        broadcaster.run()
        
    except Exception as e:
        print(f"‚ùå Failed to start broadcaster: {e}")
        input("Press Enter to exit...")
```

**2.4. L∆∞u file:**
- Trong Notepad: File ‚Üí Save (Ctrl+S)
- ƒê·∫£m b·∫£o file c√≥ t√™n `webrtc_broadcaster.py`
- Encoding: UTF-8

**2.5. Ki·ªÉm tra file:**
```bash
# Ki·ªÉm tra file ƒë√£ t·∫°o
dir webrtc_broadcaster.py

# Ki·ªÉm tra k√≠ch th∆∞·ªõc file (should be ~15KB)
```

### B∆∞·ªõc 3: Test ch·∫°y Windows Broadcaster

**3.1. Test ch·∫°y ·ª©ng d·ª•ng:**
```bash
# M·ªü Command Prompt/PowerShell as Administrator
# Chuy·ªÉn ƒë·∫øn th∆∞ m·ª•c ch·ª©a file
cd C:\webrtc_windows

# Ch·∫°y ·ª©ng d·ª•ng
python webrtc_broadcaster.py
```

**3.2. K·∫øt qu·∫£ mong ƒë·ª£i:**
```
üöÄ WebRTC Broadcaster started
üåê VPS Server: 45.76.190.6:3000
üì∫ Public Stream: http://45.76.190.6:3000
‚úÖ Running as Administrator
```

**3.3. Ki·ªÉm tra giao di·ªán:**
- C·ª≠a s·ªï GUI hi·ªán ra v·ªõi title "üé• WebRTC Broadcaster"
- VPS Configuration hi·ªÉn th·ªã ƒë√∫ng IP VPS
- Dropdown ƒë·ªÉ ch·ªçn Chrome window
- Buttons: "Refresh Windows" v√† "Start Broadcasting"
- Status: "Ready - Select a Chrome window to start"

**3.4. Test basic functions:**
```bash
# 1. M·ªü Chrome browser v·ªõi m·ªôt tab b·∫•t k·ª≥
# 2. Click "Refresh Windows" trong broadcaster
# 3. Ki·ªÉm tra dropdown c√≥ hi·ªÉn th·ªã Chrome windows kh√¥ng
# 4. Ch·ªçn m·ªôt Chrome window
# 5. Button "Start Broadcasting" ph·∫£i enabled
```

## üöÄ PH·∫¶N 3: TRI·ªÇN KHAI V√Ä S·ª¨ D·ª§NG

### B∆∞·ªõc 1: Kh·ªüi ƒë·ªông VPS Server

**1.1. SSH v√†o VPS:**
```bash
ssh root@45.76.190.6
```

**1.2. Ch·∫°y WebRTC server:**
```bash
cd ~/webrtc_server
node server.js

# K·∫øt qu·∫£:
# üöÄ WebRTC Signaling Server running on port 3000
# üåê Public URL: http://45.76.190.6:3000
# üìÅ Serving files from: /root/webrtc_server/public
```

**1.3. Ki·ªÉm tra server ho·∫°t ƒë·ªông:**
```bash
# M·ªü browser v√† truy c·∫≠p: http://45.76.190.6:3000
# B·∫°n s·∫Ω th·∫•y:
# - Trang "Live Stream from Windows PC"  
# - Status: "CONNECTED - Waiting for Windows PC..."
# - Video player m√†u ƒëen
```

### B∆∞·ªõc 2: Ch·∫°y Windows Broadcaster

**2.1. Chu·∫©n b·ªã Chrome:**
```bash
# 1. M·ªü Chrome browser
# 2. Truy c·∫≠p trang web b·∫°n mu·ªën stream (YouTube, game, etc.)
# 3. ƒê·∫£m b·∫£o Chrome window hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß
```

**2.2. Ch·∫°y broadcaster:**
```bash
# M·ªü Command Prompt as Administrator
cd C:\webrtc_windows
python webrtc_broadcaster.py
```

**2.3. C·∫•u h√¨nh broadcaster:**
```bash
# 1. Click "Refresh Windows"
# 2. Ch·ªçn Chrome window t·ª´ dropdown
# 3. Click "Start Broadcasting"
# 4. Status s·∫Ω chuy·ªÉn: "Connecting to VPS..." ‚Üí "Connected to VPS - Broadcasting..."
```

### B∆∞·ªõc 3: Xem Live Stream

**3.1. Truy c·∫≠p public URL:**
```bash
# M·ªü browser (b·∫•t k·ª≥ m√°y n√†o c√≥ internet)
# Truy c·∫≠p: http://45.76.190.6:3000
```

**3.2. K·∫øt qu·∫£ mong ƒë·ª£i:**
```bash
# Trang web s·∫Ω hi·ªÉn th·ªã:
# - Title: "Live Stream from Windows PC"
# - Status: "LIVE - Streaming from Windows PC" (m√†u xanh)
# - Video player hi·ªÉn th·ªã n·ªôi dung Chrome window t·ª´ Windows PC
# - Quality: HD v·ªõi 30 FPS
```

**3.3. Test v·ªõi multiple viewers:**
```bash
# M·ªü link tr√™n nhi·ªÅu browser/device kh√°c nhau:
# - Laptop kh√°c
# - Mobile phone  
# - Tablet
# - T·∫•t c·∫£ ƒë·ªÅu s·∫Ω xem ƒë∆∞·ª£c c√πng l√∫c
```

### B∆∞·ªõc 4: Monitoring v√† Control

**4.1. Ki·ªÉm tra VPS server log:**
```bash
# Tr√™n VPS terminal, b·∫°n s·∫Ω th·∫•y:
# Client connected: [socket_id]
# Broadcaster connected: [socket_id]  
# Viewer connected: [socket_id]
```

**4.2. Ki·ªÉm tra Windows broadcaster:**
```bash
# Tr√™n Windows command prompt:
# üëÄ Viewer connected: [viewer_id]
# üî¥ LIVE - Broadcasting frame #30
# üî¥ LIVE - Broadcasting frame #60
```

**4.3. Stop streaming:**
```bash
# Tr√™n Windows broadcaster:
# - Click "Stop Broadcasting"
# - Ho·∫∑c ƒë√≥ng ·ª©ng d·ª•ng

# Tr√™n VPS:
# - Nh·∫•n Ctrl+C ƒë·ªÉ d·ª´ng server
```
import ctypes
from tkinter import *
from tkinter import ttk, messagebox

class WebRTCBroadcaster:
    def __init__(self):
        self.websocket = None
        self.broadcasting = False
        self.selected_window = None
        
        # Create GUI
        self.setup_gui()
        
    def setup_gui(self):
        self.root = Tk()
        self.root.title("WebRTC Broadcaster")
        self.root.geometry("500x300")
        
        # Main frame
        main_frame = Frame(self.root, padx=20, pady=20)
        main_frame.pack(fill='both', expand=True)
        
        # Title
        Label(main_frame, text="üé• WebRTC Screen Broadcaster", 
              font=("Arial", 16, "bold")).pack(pady=10)
        
        # Chrome window selection
        Label(main_frame, text="Select Chrome Window:", 
              font=("Arial", 10)).pack(anchor='w', pady=(10,5))
        
        self.window_var = StringVar()
        self.window_combo = ttk.Combobox(main_frame, textvariable=self.window_var, 
                                        state='readonly', width=60)
        self.window_combo.pack(fill='x', pady=5)
        self.window_combo.bind('<<ComboboxSelected>>', self.select_window)
        
        # Buttons frame
        btn_frame = Frame(main_frame)
        btn_frame.pack(pady=20)
        
        self.refresh_btn = Button(btn_frame, text="Refresh Windows", 
                                 command=self.refresh_windows,
                                 font=("Arial", 10))
        self.refresh_btn.pack(side='left', padx=5)
        
        self.broadcast_btn = Button(btn_frame, text="Start Broadcasting", 
                                   command=self.toggle_broadcast,
                                   font=("Arial", 10),
                                   state='disabled')
        self.broadcast_btn.pack(side='left', padx=5)
        
        # Status
        self.status_label = Label(main_frame, text="Ready - Select a Chrome window to start", 
                                 font=("Arial", 10), fg="blue")
        self.status_label.pack(pady=10)
        
        # Server URL
        Label(main_frame, text="VPS Server: ws://45.76.190.6:3000", 
              font=("Arial", 9), fg="gray").pack()
        Label(main_frame, text="Public Stream: http://45.76.190.6:3000", 
              font=("Arial", 9), fg="gray").pack()
        
        # Load windows on start
        self.refresh_windows()
        
    def refresh_windows(self):
        """Refresh Chrome windows list"""
        try:
            chrome_windows = []
            windows = gw.getWindowsWithTitle('')
            
            for window in windows:
                if 'chrome' in window.title.lower() and window.visible:
                    chrome_windows.append(f"{window.title} (HWND: {window._hWnd})")
            
            self.window_combo['values'] = chrome_windows
            
            if chrome_windows:
                self.status_label.config(text=f"Found {len(chrome_windows)} Chrome windows")
            else:
                self.status_label.config(text="No Chrome windows found - Please open Chrome")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error refreshing windows: {str(e)}")
    
    def select_window(self, event=None):
        """Select Chrome window"""
        try:
            selected_text = self.window_var.get()
            if not selected_text:
                return
                
            # Extract HWND
            hwnd_str = selected_text.split('(HWND: ')[1].rstrip(')')
            hwnd = int(hwnd_str)
            
            # Get window object
            for w in gw.getWindowsWithTitle(''):
                if w._hWnd == hwnd:
                    self.selected_window = w
                    self.broadcast_btn.config(state='normal')
                    self.status_label.config(text=f"Selected: {w.title[:50]}...")
                    break
                    
        except Exception as e:
            messagebox.showerror("Error", f"Error selecting window: {str(e)}")
    
    def capture_window(self):
        """Capture selected Chrome window"""
        if not self.selected_window:
            return None
            
        try:
            hwnd = self.selected_window._hWnd
            left, top, right, bottom = win32gui.GetWindowRect(hwnd)
            width = right - left
            height = bottom - top
            
            if width <= 0 or height <= 0:
                return None
            
            # Use PrintWindow API for hidden window capture
            user32 = ctypes.windll.user32
            hwndDC = win32gui.GetWindowDC(hwnd)
            mfcDC = win32ui.CreateDCFromHandle(hwndDC)
            saveDC = mfcDC.CreateCompatibleDC()
            
            saveBitMap = win32ui.CreateBitmap()
            saveBitMap.CreateCompatibleBitmap(mfcDC, width, height)
            saveDC.SelectObject(saveBitMap)
            
            result = user32.PrintWindow(hwnd, saveDC.GetSafeHdc(), 3)
            
            if result:
                bmpstr = saveBitMap.GetBitmapBits(True)
                img = np.frombuffer(bmpstr, dtype='uint8')
                img.shape = (height, width, 4)  # BGRA
                img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
                
                # Cleanup
                win32gui.DeleteObject(saveBitMap.GetHandle())
                saveDC.DeleteDC()
                mfcDC.DeleteDC()
                win32gui.ReleaseDC(hwnd, hwndDC)
                
                return img
            else:
                # Cleanup on failure
                win32gui.DeleteObject(saveBitMap.GetHandle())
                saveDC.DeleteDC()
                mfcDC.DeleteDC()
                win32gui.ReleaseDC(hwnd, hwndDC)
                return None
                
        except Exception as e:
            print(f"Capture error: {e}")
            return None
    
    async def connect_websocket(self):
        """Connect to WebRTC signaling server"""
        try:
            self.websocket = await websockets.connect("ws://45.76.190.6:3000/socket.io/?EIO=4&transport=websocket")
            await self.websocket.send('40{"broadcaster":""}')  # Register as broadcaster
            self.status_label.config(text="üü¢ Connected to VPS - Broadcasting...", fg="green")
            
            # Start capture loop
            await self.broadcast_loop()
            
        except Exception as e:
            self.status_label.config(text=f"‚ùå Connection failed: {str(e)}", fg="red")
            print(f"WebSocket error: {e}")
    
    async def broadcast_loop(self):
        """Main broadcasting loop"""
        while self.broadcasting:
            try:
                # Capture frame
                frame = self.capture_window()
                if frame is not None:
                    # Resize for optimal streaming
                    h, w = frame.shape[:2]
                    max_width = 1280
                    if w > max_width:
                        scale = max_width / w
                        new_w = int(w * scale)
                        new_h = int(h * scale)
                        frame = cv2.resize(frame, (new_w, new_h), interpolation=cv2.INTER_LANCZOS4)
                    
                    # Encode to base64
                    _, buffer = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 85])
                    frame_b64 = base64.b64encode(buffer).decode('utf-8')
                    
                    # Send frame via WebSocket (this is simplified - real WebRTC needs more complex signaling)
                    message = json.dumps({
                        "type": "video_frame",
                        "data": frame_b64
                    })
                    
                    if self.websocket:
                        await self.websocket.send(f'42{message}')
                
                await asyncio.sleep(1/30)  # 30 FPS
                
            except Exception as e:
                print(f"Broadcast error: {e}")
                break
    
    def toggle_broadcast(self):
        """Start/stop broadcasting"""
        if not self.broadcasting:
            if not self.selected_window:
                messagebox.showerror("Error", "Please select a Chrome window first!")
                return
                
            self.broadcasting = True
            self.broadcast_btn.config(text="Stop Broadcasting")
            self.status_label.config(text="üü° Connecting to VPS...", fg="orange")
            
            # Start WebSocket in separate thread
            def run_websocket():
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                loop.run_until_complete(self.connect_websocket())
            
            self.websocket_thread = threading.Thread(target=run_websocket, daemon=True)
            self.websocket_thread.start()
            
        else:
            self.broadcasting = False
            self.broadcast_btn.config(text="Start Broadcasting")
            self.status_label.config(text="Broadcasting stopped", fg="blue")
            
            if self.websocket:
                asyncio.create_task(self.websocket.close())
    
    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    broadcaster = WebRTCBroadcaster()
    broadcaster.run()
```

## üöÄ PH·∫¶N 3: TRI·ªÇN KHAI V√Ä S·ª¨ D·ª§NG

### B∆∞·ªõc 1: Ch·∫°y VPS Server
```bash
# Tr√™n VPS
cd ~/webrtc_server
node server.js
```

### B∆∞·ªõc 2: Ch·∫°y Windows Broadcaster
```bash
# Tr√™n Windows
python webrtc_broadcaster.py
```

### B∆∞·ªõc 3: Xem Stream
M·ªü browser v√† truy c·∫≠p: **http://45.76.190.6:3000**

## üîß TROUBLESHOOTING

### L·ªói connection refused:
```bash
# Ki·ªÉm tra port c√≥ m·ªü kh√¥ng
sudo ufw status
sudo ufw allow 3000
```

### L·ªói WebRTC not working:
- ƒê·∫£m b·∫£o HTTPS ho·∫∑c localhost
- Ki·ªÉm tra browser c√≥ h·ªó tr·ª£ WebRTC kh√¥ng
- Test v·ªõi Chrome/Firefox

### L·ªói capture window:
- ƒê·∫£m b·∫£o Chrome ƒëang ch·∫°y
- Ch·ªçn ƒë√∫ng Chrome window
- Ch·∫°y Python as Administrator

## üìä K·∫æT QU·∫¢ MONG ƒê·ª¢I

- ‚úÖ **FPS**: 30 FPS m∆∞·ª£t m√†
- ‚úÖ **Quality**: 720p-1080p HD
- ‚úÖ **Latency**: 50-200ms
- ‚úÖ **Bandwidth**: T·ªëi ∆∞u v·ªõi H.264
- ‚úÖ **Multiple viewers**: Unlimited
- ‚úÖ **Cross-platform**: Windows, Mac, Mobile
- ‚úÖ **No plugins**: Ch·ªâ c·∫ßn browser

## üéØ N√ÇNG C·∫§P N√ÇNG CAO

### Th√™m Audio:
```javascript
// Th√™m v√†o broadcaster
const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
```

### TURN Server (cho NAT traversal):
```javascript
// Th√™m TURN server v√†o configuration
{
    urls: 'turn:your-turn-server.com:3478',
    username: 'user',
    credential: 'pass'
}
```

### Recording:
```javascript
// Th√™m MediaRecorder ƒë·ªÉ record stream
const recorder = new MediaRecorder(stream);
```

---
**T√°c gi·∫£**: AI Assistant  
**Ng√†y t·∫°o**: 16/09/2025  
**Phi√™n b·∫£n**: 1.0 - WebRTC High Quality Streaming
